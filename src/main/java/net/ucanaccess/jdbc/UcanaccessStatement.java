package net.ucanaccess.jdbc;

import net.ucanaccess.converters.SQLConverter;
import net.ucanaccess.exception.UcanaccessSQLException;
import net.ucanaccess.util.IThrowingRunnable;
import net.ucanaccess.util.IThrowingSupplier;
import net.ucanaccess.util.Try;
import org.hsqldb.jdbc.JDBCPreparedStatement;
import org.hsqldb.jdbc.JDBCStatement;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.Map;
import java.util.function.Function;

public class UcanaccessStatement implements Statement {

    private final UcanaccessConnection connection;
    @SuppressWarnings("checkstyle:VisibilityModifierCheck")
    protected Statement                wrapped;
    private Object                     generatedKey;
    private Map<String, String>        aliases;
    private boolean                    enableDisable;

    protected Map<String, String> getAliases() {
        return aliases;
    }

    protected void setAliases(Map<String, String> _aliases) {
        aliases = _aliases;
    }

    public UcanaccessStatement(Statement _wrapped, UcanaccessConnection _conn) {
        wrapped = _wrapped;
        connection = _conn;
    }

    private String convertSql(String _sql, UcanaccessConnection _conn) {
        if (SQLConverter.checkDDL(_sql)) {
            return _sql;
        }
        NormalizedSQL nsql = SQLConverter.convertSQL(_sql, _conn);
        aliases = nsql.getAliases();
        return preprocess(nsql.getSql());
    }

    private String convertSql(String _sql) {
        if (SQLConverter.checkDDL(_sql)) {
            return _sql;
        }
        NormalizedSQL nsql = SQLConverter.convertSQL(_sql);
        aliases = nsql.getAliases();
        return preprocess(nsql.getSql());
    }

    private String preprocess(String _sql) {
        return connection.preprocess(_sql);
    }

    @Override
    public void addBatch(String _batch) throws UcanaccessSQLException {
        tryCatch(() -> wrapped.addBatch(SQLConverter.convertSQL(_batch).getSql()));
    }

    @Override
    public void cancel() throws UcanaccessSQLException {
        tryCatch(wrapped::cancel);
    }

    @Override
    public void clearBatch() throws UcanaccessSQLException {
        tryCatch(wrapped::clearBatch);
    }

    @Override
    public void clearWarnings() throws UcanaccessSQLException {
        tryCatch(wrapped::clearWarnings);
    }

    @Override
    public void close() throws UcanaccessSQLException {
        tryCatch(wrapped::close);
    }

    @Override
    public void closeOnCompletion() throws UcanaccessSQLException {
        tryCatch(() -> {
            if (wrapped instanceof JDBCStatement) {
                ((JDBCStatement) wrapped).closeOnCompletion();
            } else if (wrapped instanceof JDBCPreparedStatement) {
                ((JDBCPreparedStatement) wrapped).closeOnCompletion();
            } else if (wrapped instanceof UcanaccessStatement) {
                UcanaccessStatement stat = (UcanaccessStatement) wrapped;
                stat.closeOnCompletion();
            } else {
                throw new UcanaccessSQLException("Internal error. Object 'wrapped' is neither a JDBCStatement nor a JDBCPreparedStatement");
            }
        });
    }

    protected void checkLastModified() throws UcanaccessSQLException {

        if (connection.getAutoCommit() || connection.isCheckModified()) {
            Connection hsqldb = tryCatch(wrapped::getConnection);
            connection.checkLastModified();
            if (hsqldb != connection.getHSQLDBConnection()) {
                reset();
            }
        }
    }

    /**
     * Executes a generic SQL operation, handling common setup and error mapping.
     * This method centralizes the logic for setting the current statement,
     * performing modification checks, and wrapping exceptions.
     *
     * @param <R> The return type of the SQL operation.
     * @param _sql The SQL string associated with the operation (used for error messages).
     * @param _supplier A supplier that provides the result of the actual SQL operation.
     * @return The result of the SQL execution, of type {@code <R>}.
     * @throws UcanaccessSQLException if an SQL error occurs during execution or wrapping.
     */
    private <R> R executeImpl(String _sql, IThrowingSupplier<R, SQLException> _supplier) throws UcanaccessSQLException {
        return tryCatch(() -> {
            connection.setCurrentStatement(this);
            checkLastModified();
            return _supplier.get();
        }, ex -> UcanaccessSQLException.wrap("Failed to execute [" + _sql + "]", ex));
    }

    @Override
    public boolean execute(String _sql) throws UcanaccessSQLException {
        return executeImpl(_sql, () -> new Execute(this, convertSql(_sql, connection)).execute());
    }

    @Override
    public boolean execute(String _sql, int _autoGeneratedKeys) throws UcanaccessSQLException {
        return executeImpl(_sql, () -> new Execute(this, convertSql(_sql, connection), _autoGeneratedKeys).execute());
    }

    @Override
    public boolean execute(String _sql, int[] _indexes) throws UcanaccessSQLException {
        return executeImpl(_sql, () -> new Execute(this, convertSql(_sql, connection), _indexes).execute());
    }

    @Override
    public boolean execute(String _sql, String[] _columnNames) throws UcanaccessSQLException {
        return executeImpl(_sql, () -> new Execute(this, _sql, _columnNames).execute());
    }

    @Override
    public int[] executeBatch() throws UcanaccessSQLException {
        return tryCatch(() -> {
            connection.setCurrentStatement(this);
            return new ExecuteUpdate(this).executeBatch();
        }, ex -> UcanaccessSQLException.wrap("Failed to execute batch", ex));
    }

    @Override
    public ResultSet executeQuery(String _sql) throws UcanaccessSQLException {
        return executeImpl(_sql, () -> new UcanaccessResultSet(wrapped.executeQuery(convertSql(_sql, connection)), this));
    }

    @Override
    public int executeUpdate(String _sql) throws UcanaccessSQLException {
        return executeImpl(_sql, () -> new ExecuteUpdate(this, convertSql(_sql)).execute());
    }

    @Override
    public int executeUpdate(String _sql, int _autoGeneratedKeys) throws UcanaccessSQLException {
        return executeImpl(_sql, () -> new ExecuteUpdate(this, convertSql(_sql), _autoGeneratedKeys).execute());
    }

    @Override
    public int executeUpdate(String _sql, int[] _indexes) throws UcanaccessSQLException {
        return executeImpl(_sql, () -> new ExecuteUpdate(this, convertSql(_sql), _indexes).execute());
    }

    @Override
    public int executeUpdate(String _sql, String[] _columnNames) throws UcanaccessSQLException {
        return executeImpl(_sql, () -> new ExecuteUpdate(this, convertSql(_sql), _columnNames).execute());
    }

    @Override
    public UcanaccessConnection getConnection() {
        return connection;
    }

    @Override
    public int getFetchDirection() throws UcanaccessSQLException {
        return tryCatch(wrapped::getFetchDirection);
    }

    @Override
    public int getFetchSize() throws UcanaccessSQLException {
        return tryCatch(wrapped::getFetchSize);
    }

    @Override
    public ResultSet getGeneratedKeys() throws UcanaccessSQLException {
        return tryCatch(() -> {
            checkLastModified();

            StringBuilder sb = new StringBuilder();
            if (generatedKey != null) {
                sb.append(" SELECT ")
                  .append(generatedKey instanceof String ? "'" + generatedKey + "'" : generatedKey)
                  .append(" AS GENERATED_KEY ").append(" FROM DUAL");
            } else {
                sb.append(" SELECT 0 ").append("AS GENERATED_KEY ").append("FROM DUAL WHERE 1=2");
            }

            Connection conn = connection.getHSQLDBConnection();
            Statement st = conn.createStatement();
            ResultSet rs = st.executeQuery(sb.toString());
            return new UcanaccessResultSet(rs, this);
        });
    }

    @Override
    public int getMaxFieldSize() throws UcanaccessSQLException {
        return tryCatch(wrapped::getMaxFieldSize);
    }

    @Override
    public int getMaxRows() throws UcanaccessSQLException {
        return tryCatch(wrapped::getMaxRows);
    }

    @Override
    public boolean getMoreResults() throws UcanaccessSQLException {
        return tryCatch(() -> wrapped.getMoreResults());
    }

    @Override
    public boolean getMoreResults(int _current) throws UcanaccessSQLException {
        return tryCatch(() -> wrapped.getMoreResults(_current));
    }

    @Override
    public int getQueryTimeout() throws UcanaccessSQLException {
        return tryCatch(wrapped::getQueryTimeout);
    }

    @Override
    public ResultSet getResultSet() throws UcanaccessSQLException {
        return tryCatch(() -> {
            ResultSet rs = wrapped.getResultSet();
            return wrapped == null || rs == null ? null : new UcanaccessResultSet(rs, this);
        });
    }

    @Override
    public int getResultSetConcurrency() throws UcanaccessSQLException {
        return tryCatch(wrapped::getResultSetConcurrency);
    }

    @Override
    public int getResultSetHoldability() throws UcanaccessSQLException {
        return tryCatch(wrapped::getResultSetHoldability);
    }

    @Override
    public int getResultSetType() throws UcanaccessSQLException {
        return tryCatch(wrapped::getResultSetType);
    }

    @Override
    public int getUpdateCount() throws UcanaccessSQLException {
        return tryCatch(() -> {
            int i = wrapped.getUpdateCount();
            return i == -1 && enableDisable ? 0 : i;
        });
    }

    @Override
    public SQLWarning getWarnings() throws UcanaccessSQLException {
        return tryCatch(wrapped::getWarnings);
    }

    Statement getWrapped() {
        return wrapped;
    }

    @Override
    public boolean isClosed() throws UcanaccessSQLException {
        return tryCatch(wrapped::isClosed);
    }

    @Override
    public boolean isCloseOnCompletion() throws UcanaccessSQLException {
        return tryCatch(wrapped::isCloseOnCompletion);
    }

    @Override
    public boolean isPoolable() throws UcanaccessSQLException {
        return tryCatch(wrapped::isPoolable);
    }

    @Override
    public boolean isWrapperFor(Class<?> _iface) throws UcanaccessSQLException {
        return tryCatch(() -> wrapped.isWrapperFor(_iface));
    }

    @Override
    public void setCursorName(String _name) throws UcanaccessSQLException {
        tryCatch(() -> wrapped.setCursorName(_name));
    }

    @Override
    public void setEscapeProcessing(boolean _enable) throws UcanaccessSQLException {
        tryCatch(() -> wrapped.setEscapeProcessing(_enable));
    }

    @Override
    public void setFetchDirection(int _direction) throws UcanaccessSQLException {
        tryCatch(() -> wrapped.setFetchDirection(_direction));
    }

    @Override
    public void setFetchSize(int _rows) throws UcanaccessSQLException {
        tryCatch(() -> wrapped.setFetchSize(_rows));
    }

    @Override
    public void setMaxFieldSize(int _max) throws UcanaccessSQLException {
        tryCatch(() -> wrapped.setMaxFieldSize(_max));
    }

    @Override
    public void setMaxRows(int _max) throws UcanaccessSQLException {
        tryCatch(() -> wrapped.setMaxRows(_max));
    }

    @Override
    public void setPoolable(boolean _poolable) throws UcanaccessSQLException {
        tryCatch(() -> wrapped.setPoolable(_poolable));
    }

    @Override
    public void setQueryTimeout(int _seconds) throws UcanaccessSQLException {
        tryCatch(() -> wrapped.setQueryTimeout(_seconds));
    }

    @Override
    public <T> T unwrap(Class<T> _iface) throws UcanaccessSQLException {
        return tryCatch(() -> wrapped.unwrap(_iface));
    }

    protected void reset() throws UcanaccessSQLException {
        Statement old = wrapped;
        Statement stat = tryCatch(() -> getConnection().getHSQLDBConnection().createStatement(
            wrapped.getResultSetType(), wrapped.getResultSetConcurrency(), wrapped.getResultSetHoldability()));
        reset(stat);
        tryCatch(old::close);
    }

    protected void reset(Statement _st) throws UcanaccessSQLException {
        tryCatch(() -> {
            int maxRows = wrapped.getMaxRows();
            int maxFldSz = wrapped.getMaxFieldSize();
            int fetchDir = wrapped.getFetchDirection();
            int fetchSz = wrapped.getFetchSize();
            int qryTimeout = wrapped.getQueryTimeout();
            wrapped = _st;
            wrapped.setMaxRows(maxRows);
            wrapped.setMaxFieldSize(maxFldSz);
            wrapped.setFetchDirection(fetchDir);
            wrapped.setFetchSize(fetchSz);
            wrapped.setQueryTimeout(qryTimeout);
        });
    }

    public void setGeneratedKey(Object key) {
        generatedKey = key;
    }

    boolean isEnableDisable() {
        return enableDisable;
    }

    void setEnableDisable(boolean _enableDisable) {
        enableDisable = _enableDisable;
    }

    protected static final <T extends Throwable> void tryCatch(IThrowingRunnable<T> _catchable) throws UcanaccessSQLException {
        Try.catching(_catchable).orThrow(UcanaccessSQLException::wrap);
    }

    protected static final <R, T extends Throwable> R tryCatch(IThrowingSupplier<R, T> _catchable) throws UcanaccessSQLException {
        return tryCatch(_catchable, UcanaccessSQLException::wrap);
    }

    protected static final <R, T extends Throwable> R tryCatch(IThrowingSupplier<R, T> _catchable, Function<T, UcanaccessSQLException> _exSupplier) throws UcanaccessSQLException {
        return Try.catching(_catchable).orThrow(_exSupplier);
    }

}
